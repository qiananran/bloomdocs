> 动态内存管理是程序在运行时根据需要分配和释放内存空间，以优化资源利用和避免内存泄漏。

![](https://photohosting.oss-cn-hangzhou.aliyuncs.com/notionCover/2243510cb87847bf9e81e1c31e87f20a.png)

## 1、new和delete操作符

### 1、动态分配单个变量

在C++中，动态分配单个变量通常通过使用 `new` 运算符来完成。这种方式允许在运行时分配内存空间，并返回指向该内存空间的指针。下面是动态分配单个变量的基本步骤和示例：

### 动态分配单个变量的步骤

1. **使用 `new` 运算符动态分配内存**：
   - `new` 运算符用于在堆（heap）上动态分配内存空间，并返回一个指向分配内存的指针。

2. **分配内存**：
   - 使用 `new` 运算符分配变量时，必须指定要分配的数据类型。例如，要分配一个整数变量的空间，可以使用 `new` 语法如下：
     ```cpp
     int *ptr = new int;
     ```
     这里 `ptr` 是一个指向动态分配的整数变量的指针。`new int` 分配了足够的内存来存储一个整数，并返回指向该内存的指针。

3. **初始化动态分配的变量**：
   - 动态分配的变量在分配内存后需要手动初始化。通常可以通过赋值来初始化：
     ```cpp
     *ptr = 42; // 初始化动态分配的整数变量为 42
     ```

4. **释放内存**：
   - 使用完动态分配的变量后，需要使用 `delete` 运算符释放分配的内存，以防止内存泄漏：
     ```cpp
     delete ptr; // 释放动态分配的整数变量的内存
     ptr = nullptr; // 将指针置为空，以避免悬空指针
     ```
     这里 `delete ptr;` 将释放由 `new int` 分配的内存，同时 `ptr = nullptr;` 将指针 `ptr` 置为空，防止悬空指针问题。

### 示例

```tabs
tab: 📖 示例
## 通过一个案例

下面是一个完整的示例，演示如何动态分配一个整数变量，并使用该变量：

...

tab: 🎯 代码
```c
#include <iostream>

int main() {
    // 动态分配一个整数变量
    int *ptr = new int;

    // 初始化动态分配的变量
    *ptr = 42;

    // 使用动态分配的变量
    std::cout << "Dynamic variable value: " << *ptr << std::endl;

    // 释放动态分配的内存
    delete ptr;
    ptr = nullptr;

    return 0;
}
tab: 🐑 总结
在这个示例中，通过 new int 动态分配了一个整数变量，然后通过 *ptr 访问和修改该变量的值。最后，使用 delete ptr; 释放了分配的内存，确保没有内存泄漏。

动态分配变量通常用于需要在运行时确定大小或生命周期的情况，但要小心使用，以避免内存泄漏和悬空指针问题。
```

### 2、动态分配数组

动态分配数组在C++中是一种常见的需求，特别是当数组的大小在运行时才能确定时。使用动态内存分配可以灵活地分配所需大小的数组，并通过指针来操作数组元素。下面是动态分配数组的基本步骤和示例：

### 动态分配数组的步骤

1. **使用 `new` 运算符动态分配内存**：
   - `new` 运算符可以用来动态分配数组。语法形式为：
     ```cpp
     type *arrayPtr = new type[size];
     ```
     其中 `type` 是数组元素的类型，`size` 是数组的大小，可以是变量或常量。

2. **初始化动态分配的数组**：
   - 动态分配数组后，可以像普通数组一样初始化数组元素。可以通过索引访问数组元素进行初始化。

3. **释放内存**：
   - 使用完动态分配的数组后，必须使用 `delete[]` 运算符释放内存，以防止内存泄漏。

### 示例

下面是一个示例，演示如何动态分配一个整数数组，并使用该数组：

```cpp
#include <iostream>

int main() {
    int size;
    std::cout << "Enter the size of the array: ";
    std::cin >> size;

    // 动态分配整数数组
    int *arrayPtr = new int[size];

    // 初始化动态分配的数组
    for (int i = 0; i < size; ++i) {
        arrayPtr[i] = i * 10; // 初始化数组元素
    }

    // 使用动态分配的数组
    std::cout << "Dynamic array elements: ";
    for (int i = 0; i < size; ++i) {
        std::cout << arrayPtr[i] << " ";
    }
    std::cout << std::endl;

    // 释放动态分配的内存
    delete[] arrayPtr;
    arrayPtr = nullptr;

    return 0;
}
```

在这个示例中，用户输入了数组的大小 `size`，然后通过 `new int[size]` 动态分配了一个包含 `size` 个整数的数组。接着使用循环初始化了数组元素，然后通过另一个循环输出了数组的元素值。最后使用 `delete[] arrayPtr;` 释放了分配的内存，并将指针 `arrayPtr` 置为空。



> [!abstract]+ 总结
> - **释放内存**：使用 `delete[]` 来释放动态分配的数组，而不是 `delete`。这是因为动态分配的数组是通过 `new[]` 分配的。
> - **避免内存泄漏**：确保在不再需要使用动态分配的数组时及时释放内存，以避免内存泄漏问题。
> - **异常安全性**：在使用动态内存时要注意异常安全，确保在发生异常时也能正确释放内存。
> 动态分配数组使得程序能够根据实际需求灵活地分配内存，但同时也需要小心管理内存以避免潜在的问题。

## 2、内存泄漏和内存溢出
### 1、内存泄漏的原因和预防

内存泄漏是指程序中动态分配的内存在不再需要使用时未能正确释放的情况。这种问题会导致程序运行过程中消耗的内存逐渐增加，最终可能导致系统性能下降甚至崩溃。以下是内存泄漏发生的原因及预防方法：

### 原因

1. **未释放动态分配的内存**：
   - 如果使用 `new` 或 `new[]` 分配了内存空间，但忘记使用 `delete` 或 `delete[]` 来释放该内存，则会造成内存泄漏。

2. **丢失指向动态分配内存的指针**：
   - 当动态分配的内存的指针被重新赋值或丢失（没有及时释放），就无法再通过该指针访问并释放对应的内存，造成内存泄漏。

3. **循环引用**：
   - 在使用智能指针或自行管理内存时，如果存在循环引用（例如两个对象相互持有对方的指针），可能会导致对象之间的内存无法正确释放，从而造成内存泄漏。

4. **异常安全性**：
   - 如果在分配内存后发生异常，并且在异常处理过程中未能正确释放内存，也可能导致内存泄漏。

### 预防方法

1. **使用智能指针**：
   - C++11引入的智能指针（如 `std::unique_ptr`, `std::shared_ptr`）能够自动管理动态分配的内存，避免手动释放内存的繁琐和可能的遗漏。

2. **遵循 RAII 原则**：
   - RAII（资源获取即初始化）是一种在对象构造时获取资源，并在对象析构时释放资源的编程习惯。通过使用对象来管理资源的生命周期，可以有效避免忘记释放内存的问题。

3. **及时释放内存**：
   - 确保在不再需要使用动态分配的内存时，及时使用 `delete` 或 `delete[]` 进行释放。

4. **注意循环引用**：
   - 对于存在可能导致循环引用的情况，考虑使用 `std::weak_ptr` 等手段打破循环引用，或者重新设计对象之间的关系，以确保内存能够正确释放。

5. **使用工具进行内存泄漏检测**：
   - 可以使用一些工具和库（如 Valgrind、AddressSanitizer）来检测程序中的内存泄漏问题，这些工具能够帮助及早发现和修复内存泄漏。

6. **小心处理异常**：
   - 在使用动态内存分配时，需要考虑异常安全性。使用 RAII 和智能指针可以在异常发生时保证资源的正确释放。

通过以上方法，可以有效预防和解决内存泄漏问题，保证程序在长时间运行中的稳定性和性能。

### 2、内存溢出的排查和解决

内存溢出（Memory Overflow）是指程序试图申请超过系统可用内存范围的内存空间，导致系统无法满足程序的内存需求。这种情况通常会导致程序崩溃或者异常终止。以下是排查和解决内存溢出问题的一般方法：

### 排查内存溢出问题

1. **查看错误消息和堆栈跟踪**：
   - 当程序崩溃时，通常会有错误消息和堆栈跟踪信息。这些信息可以帮助定位问题发生的位置和原因。

2. **检查内存申请的地方**：
   - 定位程序中动态申请内存的地方，包括使用 `new`、`malloc` 等操作。确认这些地方是否存在可能申请超出系统限制的情况。

3. **审查大内存申请**：
   - 特别关注那些申请大块内存的操作，例如数组、矩阵等。确保这些申请的大小是合理的，并且不会超出系统或硬件的限制。

4. **内存使用情况监控**：
   - 使用内存监控工具或者编写自己的代码来监控程序运行时的内存使用情况。特别关注内存使用量是否随时间增长，以及是否达到系统的极限。

5. **分析循环和递归**：
   - 如果程序中有复杂的循环或者递归结构，确保它们不会无限增长或者深度过深，从而导致内存需求超过系统能提供的限制。

6. **使用内存分析工具**：
   - 工具如 Valgrind、AddressSanitizer、Heap Profiler 等可以帮助检测内存泄漏和溢出问题，提供详细的报告和分析结果。

### 解决内存溢出问题

1. **优化内存使用**：
   - 通过优化算法和数据结构来减少内存使用量，例如使用更有效的数据结构或算法来代替占用大量内存的实现。

2. **分批处理数据**：
   - 如果需要处理大量数据，考虑分批次处理或者分段加载数据，而不是一次性加载全部数据到内存中。

3. **增加系统内存**：
   - 如果程序确实需要大量内存来运行，可以考虑增加系统的物理内存或者虚拟内存大小，以容纳程序的需求。

4. **检查资源释放**：
   - 确保在程序不再需要使用某些资源（如动态分配的内存、文件句柄等）时及时释放，避免资源长时间占用而导致内存不足。

5. **测试和验证**：
   - 在修改程序后，进行充分的测试和验证，确保修改后的程序在内存使用方面没有问题，并且能够稳定运行。

通过以上方法，可以帮助排查和解决内存溢出问题，提高程序的稳定性和性能。

