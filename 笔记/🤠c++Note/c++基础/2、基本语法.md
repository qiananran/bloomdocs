> 万丈高楼平地起，只有打好基础，才能更好地铸剑。

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=840 height=86 src="//music.163.com/outchain/player?type=2&id=1425814935&auto=1&height=66"></iframe>

![](https://photohosting.oss-cn-hangzhou.aliyuncs.com/notionCover/4439c0327c1e4092a2bf397deb56933d.jpg)

## 1、变量和数据类型

### 1、内置数据类型和修饰符

C++ 中的内置数据类型是指在语言中预定义的基本数据类型，用于存储和操作不同类型的数据。以下是 C++ 中常用的内置数据类型及其修饰符：

1. **整型（Integer types）**：
   - `int`：用于表示整数，默认为有符号的，通常占用 4 字节。
   - `short`：用于表示短整数，默认为有符号的，通常占用 2 字节。
   - `long`：用于表示长整数，默认为有符号的，通常占用 4 字节。
   - `long long`：用于表示更长的整数，默认为有符号的，通常占用 8 字节。
     以上整型可以使用无符号修饰符 `unsigned`，表示只能存储非负数。

2. **浮点型（Floating-point types）**：
   - `float`：用于表示单精度浮点数，通常占用 4 字节。
   - `double`：用于表示双精度浮点数，通常占用 8 字节。
   - `long double`：用于表示更高精度的浮点数，通常占用 12 字节或更多。

3. **字符型（Character types）**：
   - `char`：用于表示字符，占用 1 字节。
   - `wchar_t`：用于表示宽字符，占用至少 2 字节。
   - `char16_t`：用于表示 UTF-16 字符，占用 2 字节。
   - `char32_t`：用于表示 UTF-32 字符，占用 4 字节。

4. **布尔型（Boolean type）**：
   - `bool`：用于表示布尔值，只能取 `true` 或 `false`。

5. **空类型（Void type）**：
   - `void`：用于表示空类型，通常用于函数返回类型或空指针。

此外，C++ 还提供了一些修饰符，用于扩展内置数据类型的范围和存储能力：

1. **signed / unsigned**：
   - 用于修饰整型，指定是否允许存储负数。`signed` 表示有符号数，`unsigned` 表示无符号数。

2. **short / long**：
   - 用于修饰整型，指定整数的存储范围。`short` 表示短整数，`long` 表示长整数。

3. **long long**：
   - 用于修饰整型，用于表示更长的整数范围。

4. **const**：
   - 用于修饰变量，表示该变量的值在初始化后不能被修改。

5. **volatile**：
   - 用于修饰变量，表示该变量的值可能在未知的时间或方式下被改变，通常用于多线程、硬件操作等场景。

6. **mutable**：
   - 用于修饰类的成员变量，表示即使在 const 成员函数中也可以修改该变量的值。

---

### 2、常量和变量的定义

在C++中，常量和变量是用来存储和操作数据的基本元素。它们有着不同的定义方式和用途：

### 常量（Constants）：

常量是程序中固定不变的值，其值在定义后不能修改。在C++中，有两种主要的常量定义方式：

1. **const 关键字**：
   - 使用 `const` 关键字定义的常量，在定义时必须进行初始化，并且不能再修改其值。
   ```cpp
   const int MAX_SIZE = 100;
   const double PI = 3.14159;
   ```
   - `const` 常量通常用于声明可以在编译时计算出值的常量，如数组大小、数学常量等。

2. **constexpr 关键字**：
   - C++11 引入了 `constexpr` 关键字，用于声明常量表达式。`constexpr` 常量在编译时即计算其值，并且可以用于数组的长度等需要在编译时确定的常量。
   ```cpp
   constexpr double GRAVITY = 9.81;
   ```

### 变量（Variables）：

变量是用来存储可变数据的标识符，在程序执行过程中其值可以被改变。在C++中，变量的定义通常包括以下要素：

1. **数据类型**：
   - 变量必须具有确定的数据类型，例如整型、浮点型、字符型等。

2. **标识符**：
   - 变量名是程序员定义的标识符，用于在程序中引用该变量。

3. **初始化**：
   - 变量可以在定义时进行初始化，也可以在稍后的代码中赋值。
   ```cpp
   int count = 0; // 定义并初始化一个整型变量 count
   double temperature; // 定义一个双精度浮点型变量 temperature
   temperature = 25.5; // 给变量 temperature 赋值
   ```

4. **作用域**：
   - 变量的作用域决定了变量在程序中可见的范围，通常从定义点开始，到其所在代码块或函数结束。

5. **存储类型**：
   - C++ 中变量还可以具有不同的存储类别，如自动变量、静态变量、全局变量等，这些会影响变量的生命周期和可见性。

---

### 3、类型转换

在C++中，类型转换是将一种数据类型的值转换为另一种数据类型的过程。C++提供了几种类型转换的方式，包括隐式类型转换（自动类型转换）和显式类型转换（强制类型转换）。

### 1. 隐式类型转换（Implicit Conversion）：

隐式类型转换是指在不需要特别指定的情况下，编译器自动执行的类型转换。这种转换通常发生在表达式中，确保表达式的操作数具有相容的数据类型。主要的隐式类型转换包括：

- **整数提升**：当较小整数类型的值参与表达式时，会自动提升为较大整数类型。
  ```cpp
  short a = 10;
  int b = a; // short 自动转换为 int
  ```

- **算术类型转换**：当不同算术类型的操作数混合在一起时，编译器会自动将其中一个操作数转换为更广泛的类型。
  ```cpp
  int x = 5;
  double y = 2.5;
  double result = x + y; // int 被转换为 double
  ```

- **浮点数提升**：当 float 类型的操作数与 double 类型的操作数混合使用时，float 类型会自动提升为 double 类型。

### 2. 显式类型转换（Explicit Conversion）：

显式类型转换是由程序员明确指定的类型转换操作，可以在需要时强制改变数据的类型。在C++中有四种显式类型转换的方法：

- **C风格类型转换**（强制类型转换）：
  ```cpp
  int a = 10;
  double b = (double)a; // C 风格的强制类型转换
  ```

- **函数形式的类型转换**（C++风格的类型转换）：
  - `static_cast`：用于基本类型的转换，以及具有继承关系的指针或引用之间的转换。
    ```cpp
    double x = 3.14;
    int y = static_cast<int>(x); // 使用 static_cast 进行类型转换
    ```
  - `dynamic_cast`：用于在继承层次结构中进行安全的向下转换。
  - `const_cast`：用于移除 const 或 volatile 属性。
  - `reinterpret_cast`：进行底层的位级别的类型转换，如将指针转换为整数或整数转换为指针。

<font color="red">显式类型转换提供了更精确的控制，但需要程序员明确注意类型转换的安全性和有效性。过度的显式类型转换可能会使代码难以理解和维护，因此在实际应用中应谨慎使用。</font>

## 2、运算符

### 1、算术运算符

当涉及到数学运算时，C++提供了一组算术运算符，用于执行各种基本的算术操作。下面是针对每个算术运算符的详细介绍和一些示例：

1. **加法运算符 (`+`)**：用于将两个操作数相加。
   ```cpp
   int a = 5;
   int b = 3;
   int sum = a + b;  // sum = 8
   ```

2. **减法运算符 (`-`)**：用于将右操作数从左操作数中减去。
   ```cpp
   int a = 5;
   int b = 3;
   int difference = a - b;  // difference = 2
   ```

3. **乘法运算符 (`*`)**：用于将两个操作数相乘。
   ```cpp
   int a = 5;
   int b = 3;
   int product = a * b;  // product = 15
   ```

4. **除法运算符 (`/`)**：用于将左操作数除以右操作数，得到商。
   ```cpp
   int a = 10;
   int b = 2;
   int quotient = a / b;  // quotient = 5
   ```

5. **取模运算符 (`%`)**：用于计算左操作数除以右操作数后的余数。
   ```cpp
   int a = 10;
   int b = 3;
   int remainder = a % b;  // remainder = 1
   ```

这些算术运算符可以应用于整数类型（如`int`、`long`等）和浮点类型（如`float`、`double`等）。它们还支持复合赋值运算符（如`+=`、`-=`、`*=`、`/=`等），使得进行多次运算更加简洁和高效。

----

### 2、逻辑运算符

逻辑运算符在C++中用于对布尔类型的操作数执行逻辑运算，它们通常用于控制流程和决策。以下是C++中常见的逻辑运算符及其详细介绍和例子：

1. **逻辑与运算符 (`&&`)**：当且仅当两个操作数都为真时，结果才为真。
   ```cpp
   bool a = true;
   bool b = false;
   bool result = a && b;  // result = false
   ```

2. **逻辑或运算符 (`||`)**：只要有一个操作数为真，结果就为真。
   ```cpp
   bool a = true;
   bool b = false;
   bool result = a || b;  // result = true
   ```

3. **逻辑非运算符 (`!`)**：用于对操作数取反，如果操作数为真，则结果为假；如果操作数为假，则结果为真。
   ```cpp
   bool a = true;
   bool result = !a;  // result = false
   ```

这些逻辑运算符通常与条件语句（如`if`语句、`while`循环等）一起使用，用于根据表达式的真假来控制程序的流程和决策。逻辑运算符可以组合使用，以构建复杂的逻辑条件。

例如，结合逻辑运算符可以实现如下的逻辑表达式：

```cpp
int age = 25;
bool isStudent = true;
bool isTeenager = (age >= 13 && age <= 19);
bool isYoungPerson = (age <= 25 && isStudent);
bool canVote = (!isStudent || (age >= 18 && age <= 120));
```

这里，`isTeenager`检查年龄是否在13到19岁之间，`isYoungPerson`检查年龄是否不超过25岁且是学生，`canVote`检查是否不是学生或者年龄在18到120岁之间，用于判断是否可以投票。

----

### 3、位运算符                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

位运算符在C++中用于对二进制数进行逐位操作。它们可以直接操作整数类型的数据，对其进行位级别的操作和运算。以下是C++中常见的位运算符及其详细介绍和例子：

1. **按位与运算符 (`&`)**：对两个操作数的每个位执行逻辑与操作。
   ```cpp
   int a = 5;    // 二进制表示为 0101
   int b = 3;    // 二进制表示为 0011
   int result = a & b;  // result = 1 (二进制表示为 0001)
   ```

2. **按位或运算符 (`|`)**：对两个操作数的每个位执行逻辑或操作。
   ```cpp
   int a = 5;    // 二进制表示为 0101
   int b = 3;    // 二进制表示为 0011
   int result = a | b;  // result = 7 (二进制表示为 0111)
   ```

3. **按位异或运算符 (`^`)**：对两个操作数的每个位执行逻辑异或操作。
   ```cpp
   int a = 5;    // 二进制表示为 0101
   int b = 3;    // 二进制表示为 0011
   int result = a ^ b;  // result = 6 (二进制表示为 0110)
   ```

4. **按位取反运算符 (`~`)**：对操作数的每个位执行逻辑取反操作。
   ```cpp
   int a = 5;    // 二进制表示为 00000000000000000000000000000101
   int result = ~a;  // result = -6 (二进制表示为 11111111111111111111111111111010)
   ```

5. **左移运算符 (`<<`)**：将操作数的每个位向左移动指定的位数。
   ```cpp
   int a = 5;    // 二进制表示为 00000000000000000000000000000101
   int result = a << 2;  // result = 20 (二进制表示为 00000000000000000000000000010100)
   ```

6. **右移运算符 (`>>`)**：将操作数的每个位向右移动指定的位数。
   ```cpp
   int a = 20;   // 二进制表示为 00000000000000000000000000010100
   int result = a >> 2;  // result = 5 (二进制表示为 00000000000000000000000000000101)
   ```

这些位运算符可以应用于整数类型（如`int`、`long`等），并对其进行位级别的操作。它们通常用于处理底层的位操作，例如处理二进制数据、位掩码、位字段等。需要注意的是，在使用位运算符时，要确保对应的数据类型足够容纳操作后的结果。

## 3、 控制流程

### 1、if语句和条件表达式

if语句和条件表达式是C++中用于根据条件来控制程序流程的重要工具。

1. **if语句**：if语句用于根据条件的真假来执行不同的代码块。语法如下：
   ```cpp
   if (condition) {
       // 当条件为真时执行的代码块
   } else {
       // 当条件为假时执行的代码块
   }
   ```
   其中，`condition`是一个布尔表达式，当条件为真时，执行if代码块；当条件为假时，执行else代码块（可选）。

   示例：
   ```cpp
   int age = 20;
   if (age >= 18) {
       cout << "You are an adult." << endl;
   } else {
       cout << "You are a minor." << endl;
   }
   ```

2. **条件表达式**：条件表达式是一种简洁的方式来根据条件选择不同的值或执行不同的操作。它使用三元运算符`? :`，语法如下：
   ```
   expression1 ? expression2 : expression3
   ```
   如果`expression1`为真，则返回`expression2`的值；如果`expression1`为假，则返回`expression3`的值。

   示例：
   ```cpp
   int num = 10;
   string message = (num > 0) ? "Positive" : "Negative";
   cout << message << endl;
   ```

   在上述示例中，如果`num`大于0，则`message`被赋值为"Positive"，否则被赋值为"Negative"。

if语句和条件表达式是根据条件进行程序流程控制的常用工具。

---

### 2、switch语句

在C++中，`switch`语句是一种用于根据表达式的值选择执行不同代码块的控制流语句。它通常用于当有多个可能的情况需要处理时，可以有效地替代多个`if-else`语句。

### `switch`语句的基本语法

```cpp
switch (expression) {
    case constant1:
        // 如果 expression 等于 constant1，则执行这里的代码
        break;
    case constant2:
        // 如果 expression 等于 constant2，则执行这里的代码
        break;
    // 可以有更多的 case 语句
    default:
        // 如果 expression 与所有 case 不匹配，则执行这里的代码
}
```

- `expression` 是一个整数表达式或可转换为整数的表达式，例如整数变量或枚举常量。
- `case constant:` 后面跟随一个常量表达式（整数或枚举常量），表示一个可能的情况。
- 每个 `case` 后面的代码块执行完成后需要使用 `break;` 来跳出 `switch` 语句，防止继续执行后续 `case` 中的代码。
- `default:` 是可选的，用于在 `expression` 与所有 `case` 都不匹配时执行的代码块。如果没有 `default`，则当没有任何一个 `case` 匹配时，`switch` 语句将不执行任何操作。

### 示例：

```cpp
int day = 3;
switch (day) {
    case 1:
        cout << "Monday" << endl;
        break;
    case 2:
        cout << "Tuesday" << endl;
        break;
    case 3:
        cout << "Wednesday" << endl;
        break;
    case 4:
        cout << "Thursday" << endl;
        break;
    case 5:
        cout << "Friday" << endl;
        break;
    default:
        cout << "Weekend" << endl;
}
```

在这个示例中，根据变量 `day` 的值，`switch` 语句会输出对应的星期几名称。由于 `day` 的值为 `3`，所以输出结果为 "Wednesday"。

### 注意事项：
- 每个 `case` 中的常量表达式必须是唯一的，不能重复。
- `switch` 语句适合用于有多个固定选项需要选择的情况，而不是用于区间或浮点数的比较。
- 使用 `break;` 来防止“fall-through”，即执行一个 `case` 后继续执行下一个 `case` 中的代码。

`switch` 语句可以使代码更加清晰和高效，尤其是在需要根据一个表达式的值来选择不同执行路径的情况下。

---

### 3、循环结构（while、do-while、for）

在C++中，循环结构（while循环、do-while循环和for循环）是常用的控制流结构，用于重复执行一段代码直到满足特定条件。这些循环结构在不同情况下选择使用，以实现不同的迭代需求。

### 1. while循环

`while`循环在每次循环迭代之前检查条件，如果条件为真，则执行循环体内的语句。

```cpp
while (condition) {
    // 循环体内的代码
}
```

- `condition` 是一个布尔表达式。只要 `condition` 为真，循环体内的代码就会重复执行。
- 如果 `condition` 最初就为假，则循环体内的代码根本不会执行。

示例：
```cpp
int count = 0;
while (count < 5) {
    cout << count << " ";
    count++;
}
// 输出结果：0 1 2 3 4
```

### 2. do-while循环

`do-while`循环先执行一次循环体内的代码，然后检查条件是否为真，如果为真，则继续执行循环。

```cpp
do {
    // 循环体内的代码
} while (condition);
```

- `condition` 是一个布尔表达式。无论如何，至少会执行一次循环体内的代码。
- `do-while` 循环适合在确保至少执行一次循环体后再检查条件的情况。

示例：
```cpp
int count = 0;
do {
    cout << count << " ";
    count++;
} while (count < 5);
// 输出结果：0 1 2 3 4
```

### 3. for循环

`for`循环提供了一个初始化步骤、循环条件和迭代步骤的结构，适合在已知迭代次数的情况下使用。

```cpp
for (initialization; condition; update) {
    // 循环体内的代码
}
```

- `initialization` 一般用于初始化循环变量，只在循环开始时执行一次。
- `condition` 是一个布尔表达式，每次迭代开始前都会被检查。
- `update` 用于更新循环变量，在每次循环迭代结束后执行。

示例：
```cpp
for (int i = 0; i < 5; i++) {
    cout << i << " ";
}
// 输出结果：0 1 2 3 4
```

### 注意事项：
- 在使用循环结构时，务必确保循环条件能在某些时刻变为假，否则可能导致无限循环。
- `while` 和 `for` 循环适用于根据条件执行循环，而 `do-while` 循环适用于至少执行一次循环体后再根据条件决定是否继续执行。
- 循环结构中的 `break` 和 `continue` 语句可以用于提前结束循环或者跳过当前迭代。

这些循环结构提供了灵活的方式来重复执行代码块，根据具体需求选择合适的循环结构可以使代码更加清晰和高效。

## 4、 函数和参数传递

### 1、函数的定义和调用

在C++中，函数是一段封装了一系列操作的代码块，可以在程序中被重复使用。函数定义了一个操作的名称和参数，并且可以返回一个值（可选）。

### 函数的定义

函数定义的基本语法如下：

```cpp
return_type function_name(parameter1, parameter2, ...) {
    // 函数体内的代码
    // 可以包含任意数量的语句
    return value; // 可选：返回值
}
```

- `return_type` 是函数返回值的数据类型，可以是任意的C++数据类型。
- `function_name` 是函数的名称，应该能清晰地描述函数的功能。
- `parameter1, parameter2, ...` 是函数的参数列表，每个参数由类型和名称组成，参数之间使用逗号分隔。
- `value` 是可选的，表示函数的返回值。

示例：
```cpp
int add(int a, int b) {
    int sum = a + b;
    return sum;
}
```

在这个示例中，我们定义了一个名为 `add` 的函数，它接受两个整数参数 `a` 和 `b`，并返回它们的和。

### 函数的调用

函数定义后，可以通过函数名称和传递给函数的实际参数来调用它。

```cpp
return_type result = function_name(argument1, argument2, ...);
```

- `return_type` 是函数的返回值的数据类型，用于存储函数调用的结果。
- `function_name` 是函数的名称。
- `argument1, argument2, ...` 是实际参数的值，与函数定义中的参数一一对应。

示例：
```cpp
int x = 5;
int y = 10;
int sum = add(x, y);
cout << sum; // 输出结果：15
```

在这个示例中，我们通过将变量 `x` 和 `y` 的值作为实际参数传递给 `add` 函数，将返回的结果存储在 `sum` 变量中，并输出结果。

### 注意事项：
- 函数定义通常应该在程序的开头，或者在需要使用函数之前提供函数的声明。
- 函数的参数可以是任意合法的C++数据类型，包括基本数据类型、自定义类型、指针等。
- 如果函数没有返回值，可以使用 `void` 作为返回类型，表示不返回任何值。
- 函数可以在其他函数内部定义，称为嵌套函数。
- 函数的参数可以有默认值，使其在调用时可以省略。
- 函数可以重载，即有相同的名称但参数列表不同的多个函数。

---

### 2、函数参数的传递方式

在C++中，函数参数的传递方式可以分为以下几种：

### 1. 按值传递 (Pass by Value)

按值传递是最常见的参数传递方式，其中函数的参数是在调用时被复制到函数内部的局部变量中。

```cpp
void foo(int x) {
    // x 是按值传递的参数
    // 在函数内部可以修改 x 的值，但不会影响到原始参数
    x = x * 2;
    cout << "Inside foo: " << x << endl;
}

int main() {
    int num = 5;
    foo(num); // 调用 foo 函数，传递 num 的值
    cout << "Outside foo: " << num << endl;
    return 0;
}
```

输出结果：
```
Inside foo: 10
Outside foo: 5
```

在这个例子中，函数 `foo` 接收一个整数参数 `x`，在函数内部修改了 `x` 的值，但这些修改不会影响到 `main` 函数中原始的 `num` 值。

### 2. 按引用传递 (Pass by Reference)

按引用传递允许函数直接访问调用者提供的变量。这样可以使函数能够修改调用者的变量。

```cpp
void bar(int &y) {
    // y 是按引用传递的参数
    // 在函数内部修改 y 的值会直接影响到原始变量
    y = y * 2;
    cout << "Inside bar: " << y << endl;
}

int main() {
    int num = 5;
    bar(num); // 调用 bar 函数，传递 num 的引用
    cout << "Outside bar: " << num << endl;
    return 0;
}
```

输出结果：
```
Inside bar: 10
Outside bar: 10
```

在这个例子中，函数 `bar` 接收一个整数引用 `y`，在函数内部修改了 `y` 的值，这会直接影响到 `main` 函数中的 `num` 值。

### 3. 指针传递

在C++中，通过指针传递参数也是一种常见的方式。通过传递指针，函数可以间接地访问和修改调用者的变量。

```cpp
void baz(int *ptr) {
    // ptr 是一个指向 int 类型的指针
    // 可以通过解引用修改原始变量的值
    (*ptr) = (*ptr) * 2;
    cout << "Inside baz: " << (*ptr) << endl;
}

int main() {
    int num = 5;
    baz(&num); // 传递 num 的地址作为参数
    cout << "Outside baz: " << num << endl;
    return 0;
}
```

输出结果：
```
Inside baz: 10
Outside baz: 10
```

在这个例子中，函数 `baz` 接收一个指向整数的指针 `ptr`，通过解引用 `ptr` 来修改原始变量的值。

### 选择传递方式的考虑：

- **按值传递** 是最安全的方式，因为它不会影响到原始变量，适合于不需要修改调用者变量的情况。
- **按引用传递** 和 **指针传递** 允许函数修改调用者的变量，因此更适合需要修改参数或者返回多个值的情况。
- **按引用传递** 更加直观和安全，因为不需要手动管理指针，同时具有指针传递的修改能力。

选择合适的传递方式取决于函数的具体需求和对原始数据的修改需求。

---

### 3、函数重载（函数复用）

函数重载是指在同一个作用域内，可以定义多个同名但参数列表不同的函数。函数重载的目的是为了提供更加灵活和方便的函数调用方式。

函数重载的规则如下：

1. 函数名称必须相同。
2. 函数参数列表必须不同，可以包括参数的类型、个数或顺序。
3. 返回类型可以相同也可以不同，但不能仅仅通过返回类型来区分函数重载。

下面是一个函数重载的例子：

```cpp
#include <iostream>

// 函数重载示例
void print(int num) {
    std::cout << "Integer: " << num << std::endl;
}

void print(double num) {
    std::cout << "Double: " << num << std::endl;
}

void print(std::string str) {
    std::cout << "String: " << str << std::endl;
}

int main() {
    print(5);                   // 调用 print(int)
    print(3.14);                // 调用 print(double)
    print("Hello, World!");     // 调用 print(std::string)
    
    return 0;
}
```

输出结果：
```
Integer: 5
Double: 3.14
String: Hello, World!
```

在这个例子中，我们定义了三个名为 `print` 的函数，它们接收不同的参数类型。根据参数传递给函数的实际类型，编译器会自动选择合适的重载函数进行调用。

函数重载可以提高代码的可读性和可维护性，通过使用相同的函数名称来表示类似的操作，使代码更加直观和简洁。同时，函数重载也可以减少开发者的负担，因为可以使用相同的函数名称来处理不同类型的数据。