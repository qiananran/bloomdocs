> 面向对象编程是一种编程范式，通过将数据和操作封装在对象中，模拟现实世界的实体和交互，以提高代码的可维护性、可重用性和可扩展性。

![](https://photohosting.oss-cn-hangzhou.aliyuncs.com/notionCover/d4f0a9ce880411ebb6edd017c2d2eca2.png)

## 1、类和对象

### 1、类成员的访问控制

在C++中，类成员的访问控制是通过访问修饰符（access specifiers）来实现的，主要有 `public`、`protected` 和 `private` 三种。这些访问修饰符可以用于控制类的成员变量和成员函数对外部的可见性和访问权限。下面我们来详细介绍一下这三种访问修饰符及其作用，并给出相应的示例代码。

### 1. 公有（Public）
使用 `public` 访问修饰符声明的成员可以被任何函数访问，包括类外部的函数。
```cpp
class PublicExample {
public: // 成员的访问修饰符
    int publicMember; // 公有成员变量

    void publicMethod() { // 公有成员函数
        // 函数体
    }
};

int main() {
    PublicExample obj;
    obj.publicMember = 10; // 可以在类外部直接访问公有成员变量
    obj.publicMethod(); // 可以在类外部直接调用公有成员函数
    return 0;
}
```

### 2. 保护（Protected）
使用 `protected` 访问修饰符声明的成员只能被该类或者该类的子类中的函数访问，不能被类外部的函数访问。
```cpp
class ProtectedExample {
protected: // 成员的访问修饰符
    int protectedMember; // 保护成员变量

    void protectedMethod() { // 保护成员函数
        // 函数体
    }
};

class SubClass : public ProtectedExample {
public:
    void accessProtectedMember() {
        protectedMember = 20; // 可以在子类中访问基类的保护成员变量
        protectedMethod(); // 可以在子类中调用基类的保护成员函数
    }
};

int main() {
    ProtectedExample obj;
    // obj.protectedMember = 20;  // 无法在类外部直接访问保护成员变量
    // obj.protectedMethod();  // 无法在类外部直接调用保护成员函数

    SubClass subObj;
    subObj.accessProtectedMember(); // 可以在子类中访问基类的保护成员
    return 0;
}
```

### 3. 私有（Private）
使用 `private` 访问修饰符声明的成员只能被该类中的函数访问，不能被类外部或子类中的函数访问。
```cpp
class PrivateExample {
private: // 成员的访问修饰符
    int privateMember; // 私有成员变量

    void privateMethod() { // 私有成员函数
        // 函数体
    }

public:
    void accessPrivateMember() {
        privateMember = 30; // 可以在类内部直接访问私有成员变量
        privateMethod(); // 可以在类内部直接调用私有成员函数
    }
};

int main() {
    PrivateExample obj;
    // obj.privateMember = 30;  // 无法在类外部直接访问私有成员变量
    // obj.privateMethod();  // 无法在类外部直接调用私有成员函数

    obj.accessPrivateMember(); // 可以在类内部间接访问私有成员
    return 0;
}
```

通过合理设置类成员的访问控制，可以提高程序的安全性和封装性，有效地控制类的成员对外部的可见性和访问权限。

---

### 2、对象的创建和使用

在C++中，对象是类的实例化结果，可以通过创建对象来使用类的成员变量和成员函数。下面我们来介绍对象的创建和使用的方法。

### 1. 对象的创建
要创建一个对象，需要按照类定义的格式使用类名和合适的构造函数进行实例化。对象的创建可以包括以下几个步骤：
- 声明类的对象：使用类名和对象名声明一个对象。
- 调用构造函数：通过调用类的构造函数来初始化对象，并分配相应的内存空间。
- 初始化对象：可以在构造函数中对对象进行初始化操作，也可以在对象创建后使用赋值语句来对对象进行初始化。
- 销毁对象：当对象不再需要时，可以使用 `delete` 关键字销毁对象，释放对象所占用的内存空间。

下面是一个示例代码，展示了对象的创建过程：
```cpp
class Example {
private:
    int data;
public:
    Example(int d) {
        data = d;
    }
    void printData() {
        cout << "Data: " << data << endl;
    }
};

int main() {
    Example obj(10); // 声明并初始化一个Example类的对象
    obj.printData(); // 调用对象的成员函数
    return 0;
}
```

### 2. 对象的使用
创建对象后，可以通过对象名和成员运算符 `.` 来访问和操作对象的成员变量和成员函数。可以使用对象名和点操作符来访问公有成员变量和成员函数，但不能直接访问私有或保护成员。可以通过公有成员函数来间接访问私有和保护成员。

下面是一个示例代码，展示了对象的使用方法：
```cpp
class Example {
private:
    int privateData;
public:
    int publicData;

    Example(int privateValue, int publicValue) {
        privateData = privateValue;
        publicData = publicValue;
    }

    void printPrivateData() {
        cout << "Private Data: " << privateData << endl;
    }

    void printPublicData() {
        cout << "Public Data: " << publicData << endl;
    }
};

int main() {
    Example obj(10, 20);
    obj.printPrivateData(); // 通过公有成员函数访问私有成员变量
    obj.printPublicData(); // 直接访问公有成员变量

    obj.privateData = 30; // 错误！无法直接访问私有成员变量
    obj.publicData = 40; // 可以直接访问公有成员变量
    return 0;
}
```

通过对象的创建和使用，可以方便地调用类的成员函数和访问类的成员变量，实现对类的功能的操作和数据的处理。

## 2、成员函数

### 1、成员函数的定义和调用

在C++中，成员函数是定义在类中的函数，用于操作类的成员变量和实现类的功能。成员函数的定义可以在类内部或类外部进行，调用则通过类的对象来完成。下面我们详细介绍成员函数的定义和调用。

### 成员函数的定义

#### 1. 在类内部定义
在类内部定义成员函数的话，直接在类定义中实现函数体。这种方式适用于简单的函数。
```cpp
class Example {
public:
    void display() {
        cout << "This is an example of a member function defined inside the class." << endl;
    }
};
```

#### 2. 在类外部定义
在类外部定义成员函数时，只需在类内部声明函数，然后在类外部提供函数的实现。需要用到作用域解析运算符 `::` 来指明函数所属的类。
```cpp
class Example {
public:
    void display(); // 成员函数声明
};

// 成员函数的定义
void Example::display() {
    cout << "This is an example of a member function defined outside the class." << endl;
}
```

### 成员函数的调用

#### 1. 通过对象调用成员函数
要调用成员函数，需要先创建类的对象，然后使用点运算符 `.` 访问成员函数。
```cpp
int main() {
    Example obj; // 创建对象
    obj.display(); // 调用成员函数
    return 0;
}
```

#### 2. 通过指针调用成员函数
如果有一个指向对象的指针，可以使用箭头运算符 `->` 调用成员函数。
```cpp
int main() {
    Example* ptr = new Example(); // 创建对象并获取指针
    ptr->display(); // 通过指针调用成员函数
    delete ptr; // 释放动态分配的内存
    return 0;
}
```

### 示例代码

结合以上内容，以下是完整的示例代码，展示了成员函数的定义和调用方法：

```cpp
#include <iostream>
using namespace std;

class Example {
private:
    int value;

public:
    // 构造函数
    Example(int v) : value(v) {}

    // 在类内部定义的成员函数
    void displayInside() {
        cout << "Value (inside): " << value << endl;
    }

    // 在类外部定义的成员函数声明
    void displayOutside();
};

// 在类外部定义的成员函数实现
void Example::displayOutside() {
    cout << "Value (outside): " << value << endl;
}

int main() {
    Example obj(42); // 创建对象并初始化
    obj.displayInside(); // 调用在类内部定义的成员函数
    obj.displayOutside(); // 调用在类外部定义的成员函数

    Example* ptr = new Example(84); // 动态创建对象
    ptr->displayInside(); // 通过指针调用成员函数
    ptr->displayOutside(); // 通过指针调用成员函数

    delete ptr; // 释放动态分配的内存
    return 0;
}
```

在这个示例中，我们定义了一个 `Example` 类，并且演示了如何在类内部和类外部定义成员函数，以及如何通过对象和指针调用这些成员函数。通过这些方法，可以灵活地管理和使用类的成员函数，实现各种功能。

---

### 2、this指针的作用

在C++中，`this`指针是一个特殊的指针，用于指向调用成员函数的对象本身。每个非静态成员函数都有一个隐含的 `this` 指针，其作用主要有以下几点：

### 1. 访问对象的成员
通过 `this` 指针可以访问对象的成员变量和成员函数。虽然通常不需要显示地使用 `this` 指针，因为编译器会自动将成员变量和成员函数与当前对象关联起来，但在某些情况下（如参数名与成员变量名相同）使用 `this` 可以避免混淆。

```cpp
class Example {
private:
    int value;

public:
    Example(int value) {
        this->value = value; // 使用this指针区分成员变量和参数
    }

    void display() {
        cout << "Value: " << this->value << endl; // 通过this指针访问成员变量
    }
};
```

### 2. 返回对象本身
在实现链式调用（连续调用多个成员函数）时，可以使用 `this` 指针返回当前对象的引用。

```cpp
class Example {
private:
    int value;

public:
    Example& setValue(int value) {
        this->value = value;
        return *this; // 返回对象本身
    }

    void display() {
        cout << "Value: " << value << endl;
    }
};

int main() {
    Example obj;
    obj.setValue(10).setValue(20).display(); // 链式调用
    return 0;
}
```

### 3. 区分成员和非成员
有时函数参数或局部变量的名称与成员变量相同，为了区分它们，可以使用 `this` 指针明确指定成员变量。

```cpp
class Example {
private:
    int value;

public:
    void setValue(int value) {
        // 如果不使用this指针，这里的value会被解释为函数参数
        this->value = value; // 使用this指针，明确表示这是成员变量
    }

    void display() {
        cout << "Value: " << value << endl;
    }
};
```

### 4. 在拷贝构造函数和赋值操作符中使用
在拷贝构造函数和赋值操作符重载中，`this` 指针用于检查自我赋值，并正确地返回对象本身。

```cpp
class Example {
private:
    int value;

public:
    // 拷贝构造函数
    Example(const Example& other) {
        this->value = other.value;
    }

    // 赋值操作符重载
    Example& operator=(const Example& other) {
        if (this == &other) {
            return *this; // 检查自我赋值
        }
        this->value = other.value;
        return *this;
    }

    void display() {
        cout << "Value: " << value << endl;
    }
};
```

### 示例代码

结合以上内容，以下是一个完整的示例代码，展示了 `this` 指针的多种用法：

```cpp
#include <iostream>
using namespace std;

class Example {
private:
    int value;

public:
    // 构造函数
    Example(int value) {
        this->value = value; // 使用this指针区分成员变量和参数
    }

    // 拷贝构造函数
    Example(const Example& other) {
        this->value = other.value;
    }

    // 赋值操作符重载
    Example& operator=(const Example& other) {
        if (this == &other) {
            return *this; // 检查自我赋值
        }
        this->value = other.value;
        return *this;
    }

    // 成员函数返回对象本身
    Example& setValue(int value) {
        this->value = value;
        return *this;
    }

    void display() {
        cout << "Value: " << value << endl;
    }
};

int main() {
    Example obj1(10);
    obj1.display();

    Example obj2 = obj1; // 调用拷贝构造函数
    obj2.display();

    obj2.setValue(20).display(); // 链式调用

    obj1 = obj2; // 调用赋值操作符重载
    obj1.display();

    return 0;
}
```

在这个示例中，我们展示了 `this` 指针如何在构造函数、赋值操作符、成员函数中使用，以及如何实现链式调用。通过 `this` 指针，可以更灵活、清晰地管理对象成员。

## 3 构造函数和析构函数

### 1、默认构造函数和参数化构造函数

在C++中，构造函数用于在创建对象时初始化对象的成员变量。构造函数有多种类型，其中包括默认构造函数和参数化构造函数。

### 默认构造函数
默认构造函数是指不带参数的构造函数。如果类没有显式定义任何构造函数，编译器会自动生成一个默认构造函数。但如果定义了其他任何形式的构造函数（如参数化构造函数），编译器不会再生成默认构造函数，除非你显式地定义一个。

```cpp
class Example {
private:
    int value;

public:
    // 默认构造函数
    Example() {
        value = 0;
        cout << "Default constructor called" << endl;
    }

    void display() {
        cout << "Value: " << value << endl;
    }
};
```

### 参数化构造函数
参数化构造函数是带有参数的构造函数，用于在对象创建时传递初始值。通过参数化构造函数，可以在创建对象时为其成员变量赋予特定的初始值。

```cpp
class Example {
private:
    int value;

public:
    // 参数化构造函数
    Example(int v) {
        value = v;
        cout << "Parameterized constructor called" << endl;
    }

    void display() {
        cout << "Value: " << value << endl;
    }
};
```

### 同时定义默认构造函数和参数化构造函数
可以在一个类中同时定义默认构造函数和参数化构造函数，从而提供灵活的对象初始化方式。

```cpp
class Example {
private:
    int value;

public:
    // 默认构造函数
    Example() {
        value = 0;
        cout << "Default constructor called" << endl;
    }

    // 参数化构造函数
    Example(int v) {
        value = v;
        cout << "Parameterized constructor called" << endl;
    }

    void display() {
        cout << "Value: " << value << endl;
    }
};

int main() {
    Example obj1;       // 调用默认构造函数
    obj1.display();

    Example obj2(42);   // 调用参数化构造函数
    obj2.display();

    return 0;
}
```

### 注意事项
1. **默认参数**：可以在参数化构造函数中使用默认参数，从而简化代码并减少构造函数的数量。
   ```cpp
   class Example {
   private:
       int value;
   
   public:
       // 参数化构造函数使用默认参数
       Example(int v = 0) {
           value = v;
           cout << "Constructor called with value: " << value << endl;
       }
   
       void display() {
           cout << "Value: " << value << endl;
       }
   };
   
   int main() {
       Example obj1;       // 使用默认参数调用构造函数
       obj1.display();
   
       Example obj2(42);   // 传递参数调用构造函数
       obj2.display();
   
       return 0;
   }
   ```

2. **避免二义性**：如果类中定义了多个构造函数，确保它们的参数列表不同，否则编译器可能无法确定应该调用哪个构造函数。
   ```cpp
   class Example {
   private:
       int value;
   
   public:
       // 两个构造函数的参数列表必须不同
       Example() {
           value = 0;
           cout << "Default constructor called" << endl;
       }
   
       Example(int v) {
           value = v;
           cout << "Parameterized constructor called" << endl;
       }
   
       // 不同的参数类型，避免冲突
       Example(double v) {
           value = static_cast<int>(v);
           cout << "Parameterized constructor with double called" << endl;
       }
   
       void display() {
           cout << "Value: " << value << endl;
       }
   };
   ```

通过合理使用默认构造函数和参数化构造函数，你可以在创建对象时灵活地进行初始化，以满足不同的需求。

---

### 2、析构函数的作用和调用时机

### 什么是析构函数

析构函数（Destructor）是一个特殊的成员函数，当对象生命周期结束时，系统会自动调用它来清理对象占用的资源。比如，释放动态分配的内存、关闭文件或释放其他系统资源。

### 主要特点

1. **名称与类名相同**：析构函数的名称与类名相同，但在前面加一个波浪号 (`~`)。
   
   ```cpp
   class MyClass {
   public:
       ~MyClass() {
           // 清理工作
       }
   };
   ```

2. **无返回类型**：析构函数没有返回值。
   
3. **无参数**：析构函数不接受任何参数，因此不能被重载。
   
4. **系统自动调用**：通常无需手动调用析构函数，系统会在对象销毁时自动调用它。

### 析构函数的用途

析构函数的主要用途是清理对象在其生命周期中分配的资源，以防止资源泄漏。例如，释放动态内存、关闭文件、断开网络连接等。

### 析构函数的定义和使用

以下是一个基本示例，演示如何定义和使用析构函数：

```cpp
#include <iostream>
using namespace std;

class Example {
private:
    int* data;

public:
    // 构造函数
    Example(int size) {
        data = new int[size];
        cout << "Constructor called, allocated memory for array." << endl;
    }

    // 析构函数
    ~Example() {
        delete[] data;
        cout << "Destructor called, freed memory for array." << endl;
    }

    void display() {
        cout << "Display function called." << endl;
    }
};

void createLocalObject() {
    Example localObj(5);
    localObj.display();
} // 这里localObj超出作用域，析构函数被调用

int main() {
    createLocalObject();

    Example* dynamicObj = new Example(10);
    dynamicObj->display();
    delete dynamicObj; // 这里delete，析构函数被调用

    return 0;
}
```

在这个示例中：
- `Example` 类定义了一个动态分配的数组 `data`。
- 构造函数分配内存，而析构函数释放内存。
- 当 `createLocalObject` 函数中的 `localObj` 超出其作用域时，析构函数被自动调用。
- 动态分配的对象 `dynamicObj` 在 `delete` 时析构函数被调用。

### 调用时机

析构函数在以下几种情况下被调用：

1. **局部对象**：当局部对象超出其作用域时，析构函数会被调用。

   ```cpp
   void func() {
       Example obj(10); // 创建局部对象
       // ... 进行一些操作
   } // 这里超出作用域，obj 的析构函数被调用
   ```

2. **全局对象**：程序结束时，全局对象的析构函数被调用。

3. **动态分配的对象**：通过 `delete` 或 `delete[]` 释放动态分配的对象时，析构函数被调用。

   ```cpp
   void func() {
       Example* obj = new Example(10); // 动态分配对象
       // ... 进行一些操作
       delete obj; // 这里delete，obj 的析构函数被调用
   }
   ```

4. **容器中的对象**：当标准库容器（如 `std::vector`）销毁其元素时，元素的析构函数被调用。

5. **对象赋值**：在对象赋值操作中，临时对象的析构函数会在赋值操作完成后被调用。

### 虚析构函数

在涉及继承的情形中，如果基类指针指向派生类对象且通过该基类指针删除对象，那么应将基类的析构函数声明为 `virtual`，以确保正确调用派生类的析构函数。

```cpp
class Base {
public:
    virtual ~Base() {
        cout << "Base destructor called" << endl;
    }
};

class Derived : public Base {
public:
    ~Derived() {
        cout << "Derived destructor called" << endl;
    }
};

int main() {
    Base* obj = new Derived();
    delete obj; // 确保调用 Derived 的析构函数
    return 0;
}
```

在这个示例中，如果 `Base` 的析构函数不是虚函数，那么通过 `Base` 指针删除 `Derived` 对象时，只会调用 `Base` 的析构函数，而不会调用 `Derived` 的析构函数，从而导致资源泄漏。

### 注意事项

1. **避免双重释放**：确保每个资源只被释放一次，以避免双重释放问题。
   
2. **虚析构函数**：在涉及继承时，基类的析构函数应声明为 `virtual`，以确保正确调用派生类的析构函数。

3. **清理顺序**：析构函数应按资源分配的逆序清理资源。

总结而言，析构函数是管理资源和确保对象正确清理的重要机制。通过合理使用析构函数，可以有效地防止资源泄漏和未定义行为。