> 数组和字符串是编程中常用的数据结构，前者用于存储有序的元素集合，后者则表示字符序列。

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=880 height=86 src="//music.163.com/outchain/player?type=2&id=1377574592&auto=1&height=66"></iframe>

![](https://photohosting.oss-cn-hangzhou.aliyuncs.com/notionCover/edc7fcb0880411ebb6edd017c2d2eca2.png)

   ## 1、数组的使用

### 1、一维数组和多维数组的定义和初始化

在C++中，数组是一种数据结构，用于存储一组相同类型的数据。可以通过下标访问数组中的元素。根据数据的维度，数组可以分为一维数组和多维数组（如二维数组、三维数组等）。以下是关于一维数组和多维数组的定义和初始化的详细说明。

### 一维数组

#### 定义
一维数组是一个线性集合，用于存储一系列具有相同类型的元素。

```cpp
type arrayName[arraySize];
```

#### 初始化

1. **静态初始化：**
   使用花括号 `{}` 提供初始值列表。

   ```cpp
   int arr[5] = {1, 2, 3, 4, 5};
   ```

2. **部分初始化：**
   如果初始值列表的元素个数小于数组大小，未被初始化的元素会被设置为零（对于基本数据类型）。

   ```cpp
   int arr[5] = {1, 2}; // 剩余元素自动初始化为0
   ```

3. **隐式大小：**
   可以让编译器根据初始值的个数推断数组大小。

   ```cpp
   int arr[] = {1, 2, 3, 4, 5};
   ```

#### 示例
```cpp
#include <iostream>
using namespace std;

int main() {
    int numbers[5] = {10, 20, 30, 40, 50}; // 定义并初始化一维数组
    for (int i = 0; i < 5; ++i) {
        cout << "Element at index " << i << ": " << numbers[i] << endl;
    }
    return 0;
}
```

### 多维数组

#### 二维数组

二维数组用于存储矩阵形式的数据，即行和列的组合。

#### 定义
```cpp
type arrayName[rowSize][colSize];
```

#### 初始化

1. **静态初始化：**
   使用嵌套的花括号提供初始值列表。

   ```cpp
   int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
   ```

2. **部分初始化：**
   未初始化的元素会被设置为零。

   ```cpp
   int matrix[2][3] = {{1}, {4, 5}}; // 未初始化的元素自动为0
   ```

3. **隐式大小：**
   可以让编译器根据初始值的个数推断数组的大小。

   ```cpp
   int matrix[][3] = {{1, 2, 3}, {4, 5, 6}}; // 行数可以省略
   ```

#### 示例
```cpp
#include <iostream>
using namespace std;

int main() {
    int matrix[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    }; // 定义并初始化二维数组

    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << "Element at [" << i << "][" << j << "]: " << matrix[i][j] << endl;
        }
    }
    return 0;
}
```

#### 三维数组

三维数组用于存储立体数据的集合，如多个二维矩阵的集合。

#### 定义
```cpp
type arrayName[size1][size2][size3];
```

#### 初始化

1. **静态初始化：**
   使用嵌套的花括号提供初始值列表。

   ```cpp
   int arr[2][2][2] = {
       {{1, 2}, {3, 4}},
       {{5, 6}, {7, 8}}
   };
   ```

2. **部分初始化：**
   未初始化的元素会被设置为零。

   ```cpp
   int arr[2][2][2] = {
       {{1}, {3, 4}},
       {{5, 6}}
   }; // 未初始化的元素自动为0
   ```

#### 示例
```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[2][2][2] = {
        {{1, 2}, {3, 4}},
        {{5, 6}, {7, 8}}
    }; // 定义并初始化三维数组

    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                cout << "Element at [" << i << "][" << j << "][" << k << "]: " << arr[i][j][k] << endl;
            }
        }
    }
    return 0;
}
```

### 总结
- 一维数组是线性的，可以看作是一连串的变量。
- 多维数组是由多个一维数组组成的，例如二维数组是矩阵，三维数组可以视为多个矩阵的集合。
- 数组在定义时需要指定尺寸或者通过初始化列表让编译器推断尺寸。
- 静态初始化可以为数组提供初始值，未初始化的元素会自动设置为零。

---

### 2、数组元素的访问和遍历

在C++中，数组元素的访问和遍历是非常基础且常见的操作。下面我们分别介绍一维数组和多维数组的元素访问和遍历方法。

### 一维数组

#### 访问
一维数组的元素可以通过索引（从0开始）进行访问。语法如下：

```cpp
arrayName[index]
```

例如：
```cpp
int arr[5] = {10, 20, 30, 40, 50};
int firstElement = arr[0]; // 访问第一个元素，结果为10
int thirdElement = arr[2]; // 访问第三个元素，结果为30
```

#### 遍历
可以使用 `for` 循环或范围 `for` 循环来遍历一维数组的所有元素。

1. **使用 `for` 循环：**
   ```cpp
   #include <iostream>
   using namespace std;
   
   int main() {
       int arr[5] = {10, 20, 30, 40, 50};
       for (int i = 0; i < 5; ++i) {
           cout << "Element at index " << i << ": " << arr[i] << endl;
       }
       return 0;
   }
   ```

2. **使用范围 `for` 循环（C++11及以后）：**
   ```cpp
   #include <iostream>
   using namespace std;
   
   int main() {
       int arr[5] = {10, 20, 30, 40, 50};
       for (int element : arr) {
           cout << "Element: " << element << endl;
       }
       return 0;
   }
   ```

### 多维数组

#### 访问
多维数组的元素可以通过多个索引进行访问。例如，对于二维数组，访问元素的语法如下：

```cpp
arrayName[rowIndex][colIndex]
```

例如：
```cpp
int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
int firstElement = matrix[0][0]; // 访问第一个元素，结果为1
int fifthElement = matrix[1][1]; // 访问第五个元素，结果为5
```

#### 遍历
遍历多维数组时，可以使用嵌套的 `for` 循环。

1. **遍历二维数组：**
   
   ```cpp
   #include <iostream>
   using namespace std;
   
   int main() {
       int matrix[2][3] = {
           {1, 2, 3},
           {4, 5, 6}
       };
       for (int i = 0; i < 2; ++i) {
           for (int j = 0; j < 3; ++j) {
               cout << "Element at [" << i << "][" << j << "]: " << matrix[i][j] << endl;
           }
       }
       return 0;
   }
   ```
   
2. **遍历三维数组：**
   对于三维数组，需要使用三层嵌套的 `for` 循环。
   ```cpp
   #include <iostream>
   using namespace std;
   
   int main() {
       int arr[2][2][2] = {
           {{1, 2}, {3, 4}},
           {{5, 6}, {7, 8}}
       }; // 定义并初始化三维数组
   
       for (int i = 0; i < 2; ++i) {
           for (int j = 0; j < 2; ++j) {
               for (int k = 0; k < 2; ++k) {
                   cout << "Element at [" << i << "][" << j << "][" << k << "]: " << arr[i][j][k] << endl;
               }
           }
       }
       return 0;
   }
   ```

### 总结
- **访问：** 通过下标访问数组的特定元素；对于多维数组，需要提供每个维度的下标。
- **遍历：** 使用 `for` 循环或范围 `for` 循环遍历一维数组；对于多维数组，使用嵌套的 `for` 循环来遍历每个维度的元素。



## 2、字符串处理

###  1、C风格字符串和字符串常量

我们来详细讨论C++（以及C）中的字符串处理，包括C风格字符串和字符串常量的概念、定义、初始化、操作和它们之间的区别。

#### c风格字符串

#### 概念
C风格字符串是一个以 `null` 字符 (`'\0'`) 结尾的字符数组。这种表示方法来源于C语言，并被C++所继承。字符数组的每一个元素都是一个字符，最后一个元素是终止符 `'\0'`，用于标识字符串的结束。

#### 定义和初始化
1. 自动分配大小并在末尾添加 `'\0'`:
    ```cpp
    char str1[] = "Hello, World!";
    ```
    编译器会自动计算数组的大小并在末尾添加 `'\0'`。

2. 指定大小，剩余空间填充为 `'\0'`:
    ```cpp
    char str2[20] = "Hello, World!";
    ```
    数组的大小为20，未使用的部分会自动填充为 `'\0'`。

3. 手动初始化每个字符:
    ```cpp
    char str3[] = {'H', 'e', 'l', 'l', 'o', '\0'};
    ```
    这种方式需要手动添加终止符 `'\0'`。

#### 访问和修改
可以通过数组下标访问和修改字符串中的字符：
```cpp
#include <iostream>
using namespace std;

int main() {
    char str[] = "Hello";
    cout << str[0] << endl; // 输出 'H'
    str[0] = 'h';           // 修改第一个字符
    cout << str << endl;    // 输出 "hello"
    return 0;
}
```

#### 常用操作
要进行字符串操作，需要包含头文件 `<cstring>`，该头文件提供了一些常用的字符串处理函数：

1. **复制字符串**:
    ```cpp
    #include <cstring>
    
    char source[] = "Hello";
    char destination[20];
    strcpy(destination, source);
    ```

2. **连接字符串**:
    ```cpp
    strcat(destination, ", World!");
    ```

3. **比较字符串**:
    ```cpp
    if (strcmp(source, "Hello") == 0) {
        cout << "source is equal to 'Hello'" << endl;
    }
    ```

4. **获取字符串长度**:
    ```cpp
    size_t length = strlen(source);
    cout << "Length of source: " << length << endl;
    ```

#### 字符串常量

#### 概念
字符串常量（或字符串字面量）是直接写在代码中的双引号括起来的字符串，如 `"Hello, World!"`。在C++中，字符串常量的类型是 `const char*`，表示指向常量字符的指针。

#### 使用
字符串常量通常用于输出或作为函数参数：
```cpp
#include <iostream>
using namespace std;

int main() {
    const char* str = "Hello, World!";
    cout << str << endl; // 输出 "Hello, World!"
    return 0;
}
```

#### 不可修改
试图修改字符串常量中的内容会导致未定义行为，甚至可能引发程序崩溃：
```cpp
#include <iostream>
using namespace std;

int main() {
    const char* str = "Hello";
    // str[0] = 'h'; // 错误！未定义行为，可能导致程序崩溃
    return 0;
}
```

#### 内存管理
字符串常量在程序的生命周期内是只读的，并且编译器可能会对相同的字符串常量进行合并，从而节省内存。
```cpp
#include <iostream>
using namespace std;

int main() {
    const char* str1 = "Hello";
    const char* str2 = "Hello";
    if (str1 == str2) { // 可能为真，因为编译器可能将其指向同一内存地址
        cout << "str1 and str2 point to the same location" << endl;
    }
    return 0;
}
```

### 区别与总结

- **可变性**：
  - C风格字符串：是字符数组，可以修改其中的字符。
  - 字符串常量：是不可修改的 `const char*`，任何修改尝试都会导致未定义行为。

- **存储位置**：
  - C风格字符串：通常存储在栈或堆上，由程序员管理其生命周期。
  - 字符串常量：通常存储在只读数据段，由编译器管理，其生命周期贯穿整个程序运行期。

- **使用场景**：
  - C风格字符串：适合需要频繁修改的场景，如动态操作字符串内容。
  - 字符串常量：适合静态、不改变的文本，如错误信息、常量消息等。

### 示例代码
以下是一个综合示例，展示了C风格字符串和字符串常量的用法及区别：
```cpp
#include <iostream>
#include <cstring>

int main() {
    // C风格字符串
    char greeting[50] = "Hello";
    strcat(greeting, ", World!");
    std::cout << "Greeting: " << greeting << std::endl;

    // 字符串常量
    const char* constantStr = "Hello, World!";
    std::cout << "Constant String: " << constantStr << std::endl;

    // 比较两者
    if (strcmp(greeting, constantStr) == 0) {
        std::cout << "The strings are equal." << std::endl;
    } else {
        std::cout << "The strings are not equal." << std::endl;
    }

    return 0;
}
```

---

### 2、字符串库函数（strcpy、strlen、strcat等）

C语言中的字符串库函数提供了一些实用的工具来处理C风格字符串，这些函数定义在头文件 `<cstring>`（C++）或 `<string.h>`（C）中。以下是一些常用的字符串库函数及其详细解释和示例：

### 1. `strcpy`
`strcpy` 函数用于将一个字符串复制到另一个字符串。

#### 原型
```c
char* strcpy(char* destination, const char* source);
```
- `destination`：目标字符串缓冲区，必须足够大以容纳源字符串。
- `source`：要复制的源字符串。

#### 示例
```cpp
#include <iostream>
#include <cstring>

int main() {
    char src[] = "Hello, World!";
    char dest[20];

    strcpy(dest, src);

    std::cout << "Source: " << src << std::endl;
    std::cout << "Destination: " << dest << std::endl;

    return 0;
}
```

### 2. `strlen`
`strlen` 函数用于计算字符串的长度，不包括终止符 `'\0'`。

#### 原型
```c
size_t strlen(const char* str);
```
- `str`：要计算长度的字符串。

#### 示例
```cpp
#include <iostream>
#include <cstring>

int main() {
    const char* str = "Hello, World!";
    size_t length = strlen(str);

    std::cout << "Length of the string: " << length << std::endl;

    return 0;
}
```

[解释如何使用size_t](###size_t)

### 3. `strcat`
`strcat` 函数用于将一个字符串追加到另一个字符串的末尾。

#### 原型
```c
char* strcat(char* destination, const char* source);
```
- `destination`：目标字符串，必须足够大以容纳连接后的新字符串。
- `source`：要追加的源字符串。

#### 示例
```cpp
#include <iostream>
#include <cstring>

int main() {
    char dest[50] = "Hello";
    const char* src = ", World!";

    strcat(dest, src);

    std::cout << "Concatenated string: " << dest << std::endl;

    return 0;
}
```

### 4. `strcmp`
`strcmp` 函数用于比较两个字符串。它返回一个整数，表示两个字符串的比较结果。

#### 原型
```c
int strcmp(const char* str1, const char* str2);
```
- `str1` 和 `str2`：要比较的两个字符串。

返回值：
- 小于 0：`str1` 小于 `str2`
- 等于 0：`str1` 等于 `str2`
- 大于 0：`str1` 大于 `str2`

#### 示例
```cpp
#include <iostream>
#include <cstring>

int main() {
    const char* str1 = "Hello";
    const char* str2 = "World";
    const char* str3 = "Hello";

    int result1 = strcmp(str1, str2);
    int result2 = strcmp(str1, str3);

    std::cout << "Comparison result1 (Hello vs World): " << result1 << std::endl;
    std::cout << "Comparison result2 (Hello vs Hello): " << result2 << std::endl;

    return 0;
}
```

### 5. `strncpy`
`strncpy` 函数类似于 `strcpy`，但它可以指定最多复制的字符数。

#### 原型
```c
char* strncpy(char* destination, const char* source, size_t num);
```
- `destination`：目标字符串缓冲区。
- `source`：要复制的源字符串。
- `num`：最多复制的字符数。

#### 示例
```cpp
#include <iostream>
#include <cstring>

int main() {
    const char* src = "Hello, World!";
    char dest[20];

    strncpy(dest, src, 5); // 只复制前5个字符
    dest[5] = '\0'; // 手动添加终止符

    std::cout << "Source: " << src << std::endl;
    std::cout << "Destination: " << dest << std::endl;

    return 0;
}
```

### 6. `strncat`
`strncat` 函数类似于 `strcat`，但它可以指定最多追加的字符数。

#### 原型
```c
char* strncat(char* destination, const char* source, size_t num);
```
- `destination`：目标字符串缓冲区。
- `source`：要追加的源字符串。
- `num`：最多追加的字符数。

#### 示例
```cpp
#include <iostream>
#include <cstring>

int main() {
    char dest[50] = "Hello";
    const char* src = ", World!";

    strncat(dest, src, 7); // 只追加前7个字符

    std::cout << "Concatenated string: " << dest << std::endl;

    return 0;
}
```

### 7. `strchr` 和 `strrchr`
`strchr` 用于查找字符串中第一次出现的字符，`strrchr` 用于查找最后一次出现的字符。

#### 原型
```c
char* strchr(const char* str, int character);
char* strrchr(const char* str, int character);
```
- `str`：要搜索的字符串。
- `character`：要查找的字符。

#### 示例
```cpp
#include <iostream>
#include <cstring>

int main() {
    const char* str = "Hello, World!";
    char* firstOccurrence = strchr(str, 'o');
    char* lastOccurrence = strrchr(str, 'o');

    if (firstOccurrence) {
        std::cout << "First occurrence of 'o': " << firstOccurrence - str << std::endl;
    }

    if (lastOccurrence) {
        std::cout << "Last occurrence of 'o': " << lastOccurrence - str << std::endl;
    }

    return 0;
}
```

通过这些字符串库函数，您可以方便地操作和处理C风格字符串。这些函数在编写C和C++程序时非常有用，但需要注意内存管理和越界问题，以确保程序的安全和稳定。

---

### 3、C++中的string类

C++中的`string`类是标准模板库（STL）的一部分，用于表示和操作字符串。在C++中，`std::string`类提供了丰富的方法和运算符来处理字符串，使得字符串操作更加方便和高效。

以下是一些主要的功能和用法示例：

### 基本用法

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str1 = "Hello";
    std::string str2 = "World";

    // Concatenation (连接)
    std::string str3 = str1 + " " + str2;
    std::cout << str3 << std::endl;  // 输出: Hello World

    // Accessing characters (访问字符)
    char ch = str1[1];
    std::cout << ch << std::endl;  // 输出: e

    // Length of the string (字符串长度)
    std::cout << "Length of str1: " << str1.size() << std::endl;  // 输出: 5

    // Substring (子串)
    std::string sub = str3.substr(6, 5);
    std::cout << sub << std::endl;  // 输出: World

    // Find (查找)
    size_t pos = str3.find("World");
    if (pos != std::string::npos) {
        std::cout << "Found 'World' at position: " << pos << std::endl;
    }

    // Replace (替换)
    str3.replace(0, 5, "Hi");
    std::cout << str3 << std::endl;  // 输出: Hi World

    return 0;
}
```

### 常用成员函数

- **`size()` 或者 `length()`**: 返回字符串的长度。
- **`empty()`**: 检查字符串是否为空。
- **`clear()`**: 清空字符串内容。
- **`c_str()`**: 返回一个C风格的字符串（以`null`结尾的字符数组）。
- **`append(const std::string& str)`**: 将字符串`str`附加到当前字符串的末尾。
- **`insert(size_t pos, const std::string& str)`**: 在指定位置插入字符串`str`。
- **`erase(size_t pos, size_t len)`**: 移除从位置`pos`开始的`len`个字符。
- **`compare(const std::string& str)`**: 比较当前字符串与`str`。

### 字符串比较

C++的`std::string`类重载了比较运算符，可以直接使用`==`, `!=`, `<`, `>`, `<=`, `>=`来比较字符串。

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str1 = "Hello";
    std::string str2 = "World";

    if (str1 == str2) {
        std::cout << "Strings are equal" << std::endl;
    } else {
        std::cout << "Strings are not equal" << std::endl;
    }

    if (str1 < str2) {
        std::cout << str1 << " is less than " << str2 << std::endl;
    }

    return 0;
}
```

### 字符串迭代

可以使用迭代器遍历`std::string`中的每个字符，可以选择使用普通迭代器或者反向迭代器。

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello";

    for (std::string::iterator it = str.begin(); it != str.end(); ++it) {
        std::cout << *it << ' ';
    }
    std::cout << std::endl;

    for (std::string::reverse_iterator rit = str.rbegin(); rit != str.rend(); ++rit) {
        std::cout << *rit << ' ';
    }
    std::cout << std::endl;

    return 0;
}
```

上述这些只是`std::string`类的一小部分功能，C++标准库提供了更多的方法和工具来处理字符串，包括正则表达式、流操作等。详细信息可以参考C++标准库的文档。



## 附录

### size_t

`size_t` 是一种无符号整数类型，通常用于表示大小或计数。这个类型适用于描述对象的大小以及数组的索引等，因为它能够表示平台上可能的最大对象大小。 `size_t` 类型定义在头文件 `<stddef.h>` 中（C语言）和 `<cstddef>` 中（C++语言）。

### 使用场景
1. **数组索引**：由于 `size_t` 是无符号的，它不能表示负值，因此非常适合用来表示数组的索引。
2. **字符串长度**：许多字符串处理函数，如 `strlen`，返回 `size_t` 类型来表示字符串的长度。
3. **内存分配**：函数如 `malloc` 和 `calloc` 接受 `size_t` 类型的参数来指定要分配的字节数。

### 定义和使用
#### 引入头文件
确保引入相关的头文件：
- 在C语言中，引入 `<stddef.h>`：
  ```c
  #include <stddef.h>
  ```
- 在C++语言中，引入 `<cstddef>`：
  ```cpp
  #include <cstddef>
  ```

#### 示例
以下是一些使用 `size_t` 的示例：

1. **字符串长度和数组索引**：
   ```cpp
   #include <iostream>
   #include <cstring>
   
   int main() {
       const char* str = "Hello, World!";
       size_t length = strlen(str);
   
       std::cout << "Length of the string: " << length << std::endl;
   
       // 使用 size_t 进行数组索引
       for (size_t i = 0; i < length; ++i) {
           std::cout << str[i] << " ";
       }
       std::cout << std::endl;
   
       return 0;
   }
   ```

2. **内存分配**：
   ```cpp
   #include <iostream>
   #include <cstdlib> // for malloc and free
   
   int main() {
       size_t numElements = 10;
       // 使用 size_t 来指定要分配的内存大小
       int* array = (int*)malloc(numElements * sizeof(int));
   
       if (array == nullptr) {
           std::cerr << "Memory allocation failed!" << std::endl;
           return 1;
       }
   
       // 初始化数组
       for (size_t i = 0; i < numElements; ++i) {
           array[i] = i * 2;
       }
   
       // 打印数组元素
       for (size_t i = 0; i < numElements; ++i) {
           std::cout << array[i] << " ";
       }
       std::cout << std::endl;
   
       // 释放内存
       free(array);
   
       return 0;
   }
   ```

### 注意事项
1. **无符号类型**：`size_t` 是无符号类型，不能表示负值。如果需要处理负值，应使用带符号的类型，如 `int` 或 `ptrdiff_t`。
2. **平台相关性**：`size_t` 的具体大小取决于平台和编译器。在32位系统上，通常是4字节（32位），而在64位系统上，通常是8字节（64位）。
3. **避免溢出**：由于 `size_t` 是无符号类型，在进行减法运算时需要小心，避免溢出导致不可预期的结果。

通过正确使用 `size_t` 这种类型，可以提高代码的可移植性和健壮性，特别是在处理数组、字符串和内存分配时。