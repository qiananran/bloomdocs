> 模板函数允许编写通用的代码，以适应多种数据类型或数据结构，提高代码的重用性和灵活性。

![](https://photohosting.oss-cn-hangzhou.aliyuncs.com/notionCover/11ef203b524b4a7c9d9dee67ad4186fd.png)

## 1、函数模板

### 1、函数模板的定义和使用

当涉及函数模板时，深入了解其定义、使用和特化的细节非常重要。让我们更详细地讨论函数模板的几个关键方面：

### 1. 定义函数模板：

函数模板以 `template <typename T>` 或 `template <class T>` 的形式开始，其中 `T` 是一个占位符类型名，用于表示函数模板可以适用于不同的数据类型。模板定义通常包括以下几个部分：

```cpp
template <typename T>
T functionName(T param1, T param2) {
    T result = param1 + param2; // 示例：对两个参数进行加法运算
    return result;
}
```

- **`template <typename T>`**：定义了一个模板，其中 `T` 是类型参数。
- **`T functionName(T param1, T param2)`**：函数模板的声明部分，这里的参数类型为 `T`。
- **函数体**：可以在函数体中使用类型 `T` 进行通用的操作，例如加法运算。

### 2. 使用函数模板：

在使用函数模板时，编译器会根据实际参数类型生成对应的函数实例。例如：

```cpp
int main() {
    int a = 5, b = 10;
    double x = 3.5, y = 2.5;

    int intResult = functionName(a, b);         // 实例化为 int functionName(int, int)
    double doubleResult = functionName(x, y);   // 实例化为 double functionName(double, double)

    std::cout << "intResult: " << intResult << std::endl;
    std::cout << "doubleResult: " << doubleResult << std::endl;

    return 0;
}
```

在上述示例中，编译器会根据 `functionName(a, b)` 和 `functionName(x, y)` 的调用分别生成处理 `int` 和 `double` 类型的函数实例。

### 3. 函数模板的特化：

特化允许您为特定类型提供定制的实现，覆盖通用模板定义。例如，可以特化一个模板来处理特定类型的参数：

```cpp
template <>
int functionName<int>(int param1, int param2) {
    return param1 * param2; // 特化模板：对于 int 类型参数进行乘法运算
}
```

在这个特化示例中，我们指定了模板参数 `T` 为 `int`，并提供了专门处理 `int` 类型参数的实现。

### 4. 非类型模板参数：

除了类型参数外，函数模板还可以接受非类型参数。非类型参数是一个常量表达式，可以是整数、枚举、指针或引用。例如：

```cpp
template <typename T, int N>
T arraySum(const T (&array)[N]) {
    T sum = 0;
    for (int i = 0; i < N; ++i) {
        sum += array[i];
    }
    return sum;
}
```

这个例子中，`arraySum` 是一个模板函数，它接受一个数组并返回数组元素的总和。`N` 是一个非类型参数，表示数组的大小。

### 5. 模板的限制和约束：

可以通过模板的限定符和 `static_assert` 等机制对模板参数进行约束和验证，以确保参数满足特定的条件。

### 总结：

函数模板是 C++ 中强大且灵活的工具，使得可以编写可以处理多种数据类型的通用代码。通过模板，可以减少代码重复，增加代码的可重用性和可扩展性，尤其是在涉及泛型编程和容器类时，模板的应用尤为广泛。

### 2、模板参数的推断

C++中的模板参数推断是指编译器根据函数调用中的实际参数类型来推导出模板参数的具体类型。这种推断可以减少代码中的模板参数显式指定，提高代码的简洁性和可读性。

### 自动推断模板参数类型

当调用模板函数时，编译器会尝试根据函数参数的类型推断模板参数类型。例如，考虑以下函数模板：

```cpp
template <typename T>
void print(T value) {
    std::cout << value << std::endl;
}
```

你可以这样调用 `print` 函数，而无需显式指定模板参数：

```cpp
int intValue = 5;
double doubleValue = 3.14;

print(intValue);      // 编译器推断 T 为 int
print(doubleValue);   // 编译器推断 T 为 double
```

在这个例子中，编译器分别推断了 `print(intValue)` 和 `print(doubleValue)` 中的 `T` 类型为 `int` 和 `double`。

### 函数模板参数推断的限制

模板参数推断有一些限制和规则，包括以下几点：

1. **显式指定模板参数类型**：有时候，必须显式指定模板参数类型，特别是当编译器无法推断出唯一的合适类型时。例如：

   ```cpp
   template <typename T>
   void process(T value);

   process<int>(5);   // 显式指定 T 为 int
   ```

2. **多个参数的推断**：如果模板函数有多个模板参数，编译器会尝试同时推断所有参数的类型。但有时需要显式指定其中一部分参数。

3. **默认模板参数**：如果函数模板有默认的模板参数，可以根据默认参数进行推断。

### 类型推断的技术细节

在 C++17 中引入了类模板参数推断，允许类模板从构造函数参数推断模板参数类型。例如：

```cpp
template <typename T>
struct MyContainer {
    T value;
    MyContainer(T val) : value(val) {}
};

MyContainer mc(42); // 推断 T 为 int
```

在这里，编译器推断出 `MyContainer<int>`，因为构造函数参数是 `int` 类型。

### 总结

模板参数推断使得模板使用更加灵活和方便，减少了冗余的类型信息，并提高了代码的可维护性。但在某些情况下，可能需要显式指定模板参数类型，特别是当推断不够准确或不唯一时。


## 2、类模板
### 1、类模板的定义和实例化

类模板是 C++ 中一种能够根据不同的类型参数生成多个类定义的工具。它类似于函数模板，但是用于类的情况。让我们深入了解类模板的定义和实例化的细节：

### 1. 定义类模板

类模板的定义以 `template <typename T>` 或 `template <class T>` 开始，后面跟着类的定义。例如，定义一个简单的类模板 `Pair`，用于存储两个值：

```cpp
template <typename T1, typename T2>
class Pair {
private:
    T1 first;
    T2 second;
public:
    Pair(T1 f, T2 s) : first(f), second(s) {}

    T1 getFirst() const { return first; }
    T2 getSecond() const { return second; }
};
```

在这个例子中，`Pair` 是一个类模板，它有两个模板参数 `T1` 和 `T2`，分别表示两个成员变量的类型。

### 2. 实例化类模板

类模板的实例化是指根据具体的模板参数生成特定类型的类。可以通过两种方式进行实例化：

- **显式实例化**：在使用类模板时显式指定模板参数类型。
  
  ```cpp
  Pair<int, double> p1(5, 3.14);
  ```

  这里 `Pair<int, double>` 是一个具体的类类型，对应的 `first` 和 `second` 分别是 `int` 和 `double` 类型。

- **隐式实例化**：编译器根据构造函数参数类型自动推断模板参数类型。
  
  ```cpp
  Pair p2(10, 4.5); // 根据构造函数参数类型推断 T1 为 int，T2 为 double
  ```

  在这种情况下，编译器会根据传递给构造函数的参数类型来推断模板参数 `T1` 和 `T2` 的类型。

### 3. 使用类模板实例

实例化后的类模板可以像普通类一样使用。例如，可以调用其成员函数或访问其成员变量：

```cpp
int main() {
    Pair<int, double> p(7, 2.5);
    std::cout << "First: " << p.getFirst() << ", Second: " << p.getSecond() << std::endl;
    return 0;
}
```

这段代码中，`p` 是一个 `Pair<int, double>` 类型的对象，使用了 `getFirst()` 和 `getSecond()` 函数来获取其成员变量的值。

### 4. 类模板特化

类模板特化允许您为特定的模板参数提供定制的实现。例如，可以特化 `Pair` 类模板来处理特定类型的情况：

```cpp
template <>
class Pair<int, double> {
private:
    int first;
    double second;
public:
    Pair(int f, double s) : first(f), second(s) {}

    int getFirst() const { return first; }
    double getSecond() const { return second; }
};
```

在这个特化示例中，我们提供了对 `<int, double>` 类型的特殊实现。

### 总结

类模板是 C++ 中用于生成多个类定义的重要工具，能够根据不同的模板参数生成具有相似结构但具有不同类型的类。通过类模板，可以有效地实现代码的重用和泛化。

### 2、模板类的成员函数和静态成员

模板类的成员函数和静态成员与普通类有一些相似之处，但也有一些特殊的考虑因素。让我们来详细看看：

### 成员函数

1. **普通成员函数**：
   - 模板类的普通成员函数定义方式和普通类类似，但要注意模板参数的使用。
   - 成员函数可以直接访问模板类的非静态成员变量和静态成员变量。

   ```cpp
   template <typename T>
   class MyClass {
   private:
       T data;
       static int count;
   
   public:
       MyClass(T data) : data(data) {}
   
       T getData() { return data; }
   
       static void incrementCount() {
           count++;
       }
   };
   
   // 静态成员变量需要在类外初始化
   template <typename T>
   int MyClass<T>::count = 0;
   ```

2. **静态成员函数**：
   - 静态成员函数可以直接访问模板类的静态成员变量，但不能直接访问非静态成员变量，因为静态函数没有this指针。
   - 静态成员函数在模板类外部定义时，需要带有模板参数。

   ```cpp
   template <typename T>
   class MyClass {
   private:
       static int count;
   
   public:
       static void incrementCount() {
           count++;
       }
   };
   
   // 静态成员变量初始化
   template <typename T>
   int MyClass<T>::count = 0;
   ```

### 特殊考虑因素

- **模板参数的影响**：
  - 模板参数可以影响成员函数的具体实现和行为。
  - 模板类的成员函数和静态成员函数的定义通常放在头文件中，以便编译器可以实例化所有需要的版本。

- **静态成员变量的初始化**：
  - 静态成员变量的初始化在模板类外部进行，需要注意每个模板参数对应的静态成员变量应该有自己的实例化版本。

### 示例

下面是一个简单的示例，展示了模板类的成员函数和静态成员的定义和使用：

```cpp
#include <iostream>

template <typename T>
class MyClass {
private:
    T data;
    static int count;

public:
    MyClass(T data) : data(data) {}

    T getData() { return data; }

    static void incrementCount() {
        count++;
    }

    static int getCount() {
        return count;
    }
};

// 初始化静态成员变量
template <typename T>
int MyClass<T>::count = 0;

int main() {
    MyClass<int> obj1(10);
    MyClass<double> obj2(3.14);

    // 使用成员函数
    std::cout << "obj1 data: " << obj1.getData() << std::endl;
    std::cout << "obj2 data: " << obj2.getData() << std::endl;

    // 使用静态成员函数
    MyClass<int>::incrementCount();
    MyClass<double>::incrementCount();

    std::cout << "Count: " << MyClass<int>::getCount() << std::endl;
    std::cout << "Count: " << MyClass<double>::getCount() << std::endl;

    return 0;
}
```

这个示例展示了如何定义和使用模板类的成员函数和静态成员。记住，在编写模板类时，要特别注意模板参数的影响，以及静态成员变量的正确实例化和使用方式。

