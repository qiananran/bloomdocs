> 我将介绍一些 MySQL 高级查询的知识，包括子查询、联接、联合查询、窗口函数、存储过程和触发器等高级主题。🚀

<iframe allow="autoplay *; encrypted-media *;" frameborder="0" height="150" style="width:100%;max-width:880px;overflow:hidden;background:transparent;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://embed.music.apple.com/cn/album/%E5%8B%BF%E5%BF%98%E5%BF%83%E5%AE%89-live/1696223112?i=1696223567"></iframe>

![](https://photohosting.oss-cn-hangzhou.aliyuncs.com/notionCover/4c1b704ee20e4b5fa28fcac2a82a32d5.jpg)

## 基本概述

### 1. 子查询（Subqueries）

子查询是一个嵌套在另一个查询中的查询，通常用于复杂的查询条件。

**例子：**
```sql
-- 查询工资高于平均工资的员工
SELECT *
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

### 2. 联接（Joins）
联接用于从多个表中检索数据。最常见的联接类型有内联接（INNER JOIN）、左联接（LEFT JOIN）、右联接（RIGHT JOIN）和全外部联接（FULL OUTER JOIN）。

**例子：**
```sql
-- 内联接
SELECT employees.name, departments.department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.id;

-- 左联接
SELECT employees.name, departments.department_name
FROM employees
LEFT JOIN departments ON employees.department_id = departments.id;
```

### 3. 联合查询（UNION 和 UNION ALL）
联合查询用于合并多个 SELECT 语句的结果集。`UNION` 会去除重复的记录，而 `UNION ALL` 则保留所有记录。

**例子：**
```sql
-- UNION
SELECT name FROM employees
UNION
SELECT name FROM managers;

-- UNION ALL
SELECT name FROM employees
UNION ALL
SELECT name FROM managers;
```

### 4. 窗口函数（Window Functions）
窗口函数执行计算操作并返回基于一组行的结果，与聚合函数不同的是，窗口函数不会对多行进行分组。

**例子：**
```sql
-- 使用 ROW_NUMBER() 窗口函数为每个员工分配一个唯一的行号
SELECT employee_id, salary,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rank
FROM employees;

-- 使用 AVG() 窗口函数计算部门内的平均工资
SELECT employee_id, department_id, salary,
       AVG(salary) OVER (PARTITION BY department_id) as avg_department_salary
FROM employees;
```

### 5. 存储过程（Stored Procedures）
存储过程是一组预编译的 SQL 语句，可以封装业务逻辑，提高代码的重用性和维护性。

**例子：**
```sql
DELIMITER //

CREATE PROCEDURE GetEmployeeById(IN emp_id INT)
BEGIN
    SELECT * FROM employees WHERE employee_id = emp_id;
END //

DELIMITER ;

-- 调用存储过程
CALL GetEmployeeById(101);
```

### 6. 触发器（Triggers）
触发器是在特定事件发生时自动执行的 SQL 代码块，例如在表插入、更新或删除时触发。

**例子：**
```sql
-- 创建一个在更新员工薪水时触发的触发器
CREATE TRIGGER before_salary_update
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
    IF NEW.salary > OLD.salary THEN
        INSERT INTO salary_changes(employee_id, old_salary, new_salary, change_date)
        VALUES (OLD.employee_id, OLD.salary, NEW.salary, NOW());
    END IF;
END;
```

### 7. 索引（Indexes）
索引可以加速数据库查询，但也会增加写操作的开销。因此，需要合理使用索引。

**例子：**
```sql
-- 为 employees 表的 employee_id 列创建一个索引
CREATE INDEX idx_employee_id ON employees(employee_id);
```

### 8. 视图（Views）
视图是基于 SQL 查询结果集的虚拟表，允许你简化复杂查询并提高代码的可读性。

**例子：**
```sql
-- 创建一个视图显示高薪员工的信息
CREATE VIEW HighSalaryEmployees AS
SELECT name, department_id, salary
FROM employees
WHERE salary > 10000;

-- 使用视图查询
SELECT * FROM HighSalaryEmployees;
```

### 9. 分区（Partitioning）
分区将大表拆分成更小的、独立管理的部分，以提高查询性能。

**例子：**
```sql
-- 创建一个按年份分区的表
CREATE TABLE sales (
    sale_id INT,
    sale_date DATE,
    amount DECIMAL(10, 2)
)
PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p0 VALUES LESS THAN (2022),
    PARTITION p1 VALUES LESS THAN (2023),
    PARTITION p2 VALUES LESS THAN (2024)
);
```

### 10. 权限管理（Permissions）
权限管理控制用户在数据库中的操作权限。

**例子：**
```sql
-- 创建用户并授予选择权限
CREATE USER 'new_user'@'localhost' IDENTIFIED BY 'password';
GRANT SELECT ON database_name.* TO 'new_user'@'localhost';

-- 撤销权限
REVOKE SELECT ON database_name.* FROM 'new_user'@'localhost';
```

### 11. 优化查询（Query Optimization）
优化查询可以显著提高数据库性能。常见的方法包括使用索引、避免子查询、优化联接等。

**例子：**
```sql
-- 查看查询执行计划
EXPLAIN SELECT * FROM employees WHERE salary > 5000;

```

## 项目实战

让我们设计一个涉及多个高级查询技术的实战项目。假设我们有一个在线书店的数据库，包括如下几个表：

- `books`: 存储书籍信息
- `authors`: 存储作者信息
- `orders`: 存储订单信息
- `customers`: 存储客户信息
- `order_items`: 存储订单中的每个书籍

### 表结构
1. `books` 表：
    ```sql
    CREATE TABLE books (
        book_id INT PRIMARY KEY,
        title VARCHAR(255),
        author_id INT,
        price DECIMAL(10, 2),
        published_date DATE,
        stock INT
    );
    ```

2. `authors` 表：
    ```sql
    CREATE TABLE authors (
        author_id INT PRIMARY KEY,
        name VARCHAR(255)
    );
    ```

3. `orders` 表：
    ```sql
    CREATE TABLE orders (
        order_id INT PRIMARY KEY,
        customer_id INT,
        order_date DATE,
        status VARCHAR(50)
    );
    ```

4. `customers` 表：
    ```sql
    CREATE TABLE customers (
        customer_id INT PRIMARY KEY,
        name VARCHAR(255),
        email VARCHAR(255)
    );
    ```

5. `order_items` 表：
    ```sql
    CREATE TABLE order_items (
        order_item_id INT PRIMARY KEY,
        order_id INT,
        book_id INT,
        quantity INT,
        price DECIMAL(10, 2)
    );
    ```

好的，我可以为每张表展示一些高级查询示例：

### 1. 查询书籍表 (`books`)

- **查询所有书籍及其作者:**

```sql
SELECT b.book_id, b.title, a.name
FROM books b
JOIN authors a ON b.author_id = a.author_id;
```

- **按照价格范围查询书籍:**

```sql
SELECT *
FROM books
WHERE price BETWEEN 10.00 AND 50.00;
```

### 2. 查询作者表 (`authors`)

- **查询所有作者及其写过的书籍数量:**

```sql
SELECT a.author_id, a.author_name, COUNT(b.book_id) AS books_written
FROM authors a
LEFT JOIN books b ON a.author_id = b.author_id
GROUP BY a.author_id, a.author_name;
```

- **按照作者名字进行模糊搜索:**

```sql
SELECT *
FROM authors
WHERE author_name LIKE '%Smith%';
```

### 3. 查询订单表 (`orders`)

- **查询特定顾客的所有订单及订单总金额:**

```sql
SELECT o.order_id, o.order_date, SUM(oi.quantity * oi.price) AS total_amount
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
WHERE o.customer_id = 101
GROUP BY o.order_id, o.order_date;
```

- **查询某个时间段内的订单数量和总金额:**

```sql
SELECT COUNT(order_id) AS num_orders, SUM(total_amount) AS total_sales
FROM (
    SELECT o.order_id, SUM(oi.quantity * oi.price) AS total_amount
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31'
    GROUP BY o.order_id
) AS order_summary;
```

### 4. 查询客户表 (`customers`)

- **查询客户的订单数量及总金额:**

```sql
SELECT c.customer_id, c.name, COUNT(o.order_id) AS num_orders, SUM(oi.quantity * oi.price) AS total_spent
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY c.customer_id, c.name;
```

- **按照客户注册时间进行排序:**

```sql
SELECT *
FROM customers
ORDER BY registration_date DESC;
```

### 5. 查询订单项表 (`order_items`)

- **查询某个订单的所有书籍及其详细信息:**

```sql
SELECT oi.order_item_id, b.title, oi.quantity, oi.price
FROM order_items oi
JOIN books b ON oi.book_id = b.book_id
WHERE oi.order_id = 1;
```

- **查询销售额最高的书籍:**

```sql
SELECT b.book_id, b.title, SUM(oi.quantity * oi.price) AS total_sales
FROM order_items oi
JOIN books b ON oi.book_id = b.book_id
GROUP BY b.book_id, b.title
ORDER BY total_sales DESC
LIMIT 1;
```

这些查询展示了如何根据表的结构和字段进行各种类型的高级查询，包括连接多张表、聚合函数的使用、条件筛选和排序等操作。你可以根据具体需求进一步调整和扩展这些查询。
### 实战任务

#### 任务1：查询总销售额最高的书籍
我们将使用子查询和联接来计算每本书籍的总销售额，并找出销售额最高的书籍。

```sql
SELECT b.title, SUM(oi.quantity * oi.price) AS total_sales
FROM order_items oi
JOIN books b ON oi.book_id = b.book_id
GROUP BY b.title
ORDER BY total_sales DESC
LIMIT 1;
```

#### 任务2：查找每个作者的总销售额
我们将使用联接和聚合函数来计算每个作者的总销售额。

```sql
SELECT a.name, SUM(oi.quantity * oi.price) AS total_sales
FROM authors a
JOIN books b ON a.author_id = b.author_id
JOIN order_items oi ON b.book_id = oi.book_id
GROUP BY a.name
ORDER BY total_sales DESC;
```

#### 任务3：查找所有订单中包含的书籍数量超过10本的订单
这将使用联接和 HAVING 子句。

```sql
SELECT o.order_id, SUM(oi.quantity) AS total_books
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY o.order_id
HAVING total_books > 10;
```

#### 任务4：创建一个视图，显示每个客户的订单和他们购买的书籍
我们将创建一个视图，简化对客户订单和书籍信息的查询。

```sql
CREATE VIEW CustomerOrders AS
SELECT c.name AS customer_name, o.order_id, o.order_date, b.title, oi.quantity, oi.price
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN books b ON oi.book_id = b.book_id;

-- 使用视图
SELECT * FROM CustomerOrders WHERE customer_name = 'John Doe';
```

#### 任务5：创建一个存储过程，查询特定时间段内的销售额
我们将创建一个存储过程，根据输入的开始日期和结束日期，计算该时间段内的总销售额。

```sql
DELIMITER //

CREATE PROCEDURE GetSalesByDateRange(IN start_date DATE, IN end_date DATE)
BEGIN
    SELECT SUM(oi.quantity * oi.price) AS total_sales
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    WHERE o.order_date BETWEEN start_date AND end_date;
END //

DELIMITER ;

-- 调用存储过程
CALL GetSalesByDateRange('2023-01-01', '2023-12-31');
```

#### 任务6：为订单状态更新创建触发器
我们将创建一个触发器，在订单状态更新时记录更新前后的状态。

```sql
CREATE TABLE order_status_changes (
    change_id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT,
    old_status VARCHAR(50),
    new_status VARCHAR(50),
    change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

DELIMITER //

CREATE TRIGGER before_order_status_update
BEFORE UPDATE ON orders
FOR EACH ROW
BEGIN
    IF NEW.status <> OLD.status THEN
        INSERT INTO order_status_changes(order_id, old_status, new_status)
        VALUES (OLD.order_id, OLD.status, NEW.status);
    END IF;
END //

DELIMITER ;
```

### 任务7：优化查询性能
为 `books` 表的 `title` 列和 `orders` 表的 `order_date` 列创建索引，以加速查询。

```sql
CREATE INDEX idx_books_title ON books(title);
CREATE INDEX idx_orders_order_date ON orders(order_date);
```

### 总结
通过上述任务，你将练习多个 MySQL 高级查询技术，包括子查询、联接、视图、存储过程、触发器、索引等。这些技术在实际项目中非常有用，可以帮助你更高效地管理和操作数据库。
